# Automatically @generated by scripts/vm_vyper.py. Do not modify manually.

# A modification applied to either `msg.sender` or `tx.origin`. Returned by `readCallers`.
enum CallerMode:
    # No caller modification is currently active.
    None_
    # A one time broadcast triggered by a `vm.broadcast()` call is currently active.
    Broadcast
    # A recurrent broadcast triggered by a `vm.startBroadcast()` call is currently active.
    RecurrentBroadcast
    # A one time prank triggered by a `vm.prank()` call is currently active.
    Prank
    # A recurrent prank triggered by a `vm.startPrank()` call is currently active.
    RecurrentPrank

# The kind of account access that occurred.
enum AccountAccessKind:
    # The account was called.
    Call
    # The account was called via delegatecall.
    DelegateCall
    # The account was called via callcode.
    CallCode
    # The account was called via staticcall.
    StaticCall
    # The account was created.
    Create
    # The account was selfdestructed.
    SelfDestruct
    # Synthetic access indicating the current context has resumed after a previous sub-context (AccountAccess).
    Resume
    # The account's balance was read.
    Balance
    # The account's codesize was read.
    Extcodesize
    # The account's codehash was read.
    Extcodehash
    # The account's code was copied.
    Extcodecopy

# Forge execution contexts.
enum ForgeContext:
    # Test group execution context (test, coverage or snapshot).
    TestGroup
    # `forge test` execution context.
    Test
    # `forge coverage` execution context.
    Coverage
    # `forge snapshot` execution context.
    Snapshot
    # Script group execution context (dry run, broadcast or resume).
    ScriptGroup
    # `forge script` execution context.
    ScriptDryRun
    # `forge script --broadcast` execution context.
    ScriptBroadcast
    # `forge script --resume` execution context.
    ScriptResume
    # Unknown `forge` execution context.
    Unknown

# An Ethereum log. Returned by `getRecordedLogs`.
struct Log:
    # The topics of the log, including the signature, if any.
    topics: DynArray[bytes32, 1024]
    # The raw data of the log.
    data: Bytes[1024]
    # The address of the log's emitter.
    emitter: address

# An RPC URL and its alias. Returned by `rpcUrlStructs`.
struct Rpc:
    # The alias of the RPC URL.
    key: String[1024]
    # The RPC URL.
    url: String[1024]

# An RPC log object. Returned by `eth_getLogs`.
struct EthGetLogs:
    # The address of the log's emitter.
    emitter: address
    # The topics of the log, including the signature, if any.
    topics: DynArray[bytes32, 1024]
    # The raw data of the log.
    data: Bytes[1024]
    # The block hash.
    blockHash: bytes32
    # The block number.
    blockNumber: uint64
    # The transaction hash.
    transactionHash: bytes32
    # The transaction index in the block.
    transactionIndex: uint64
    # The log index.
    logIndex: uint256
    # Whether the log was removed.
    removed: bool

# A single entry in a directory listing. Returned by `readDir`.
struct DirEntry:
    # The error message, if any.
    errorMessage: String[1024]
    # The path of the entry.
    path: String[1024]
    # The depth of the entry.
    depth: uint64
    # Whether the entry is a directory.
    isDir: bool
    # Whether the entry is a symlink.
    isSymlink: bool

# Metadata information about a file.
# This structure is returned from the `fsMetadata` function and represents known
# metadata about a file such as its permissions, size, modification
# times, etc.
struct FsMetadata:
    # True if this metadata is for a directory.
    isDir: bool
    # True if this metadata is for a symlink.
    isSymlink: bool
    # The size of the file, in bytes, this metadata is for.
    length: uint256
    # True if this metadata is for a readonly (unwritable) file.
    readOnly: bool
    # The last modification time listed in this metadata.
    modified: uint256
    # The last access time of this metadata.
    accessed: uint256
    # The creation time listed in this metadata.
    created: uint256

# A wallet with a public and private key.
struct Wallet:
    # The wallet's address.
    addr: address
    # The wallet's public key `X`.
    publicKeyX: uint256
    # The wallet's public key `Y`.
    publicKeyY: uint256
    # The wallet's private key.
    privateKey: uint256

# The result of a `tryFfi` call.
struct FfiResult:
    # The exit code of the call.
    exitCode: int32
    # The optionally hex-decoded `stdout` data.
    stdout: Bytes[1024]
    # The `stderr` data.
    stderr: Bytes[1024]

# Information on the chain and fork.
struct ChainInfo:
    # The fork identifier. Set to zero if no fork is active.
    forkId: uint256
    # The chain ID of the current fork.
    chainId: uint256

# The result of a `stopAndReturnStateDiff` call.
struct AccountAccess:
    # The chain and fork the access occurred.
    chainInfo: ChainInfo
    # The kind of account access that determines what the account is.
    # If kind is Call, DelegateCall, StaticCall or CallCode, then the account is the callee.
    # If kind is Create, then the account is the newly created account.
    # If kind is SelfDestruct, then the account is the selfdestruct recipient.
    # If kind is a Resume, then account represents a account context that has resumed.
    kind: AccountAccessKind
    # The account that was accessed.
    # It's either the account created, callee or a selfdestruct recipient for CREATE, CALL or SELFDESTRUCT.
    account: address
    # What accessed the account.
    accessor: address
    # If the account was initialized or empty prior to the access.
    # An account is considered initialized if it has code, a
    # non-zero nonce, or a non-zero balance.
    initialized: bool
    # The previous balance of the accessed account.
    oldBalance: uint256
    # The potential new balance of the accessed account.
    # That is, all balance changes are recorded here, even if reverts occurred.
    newBalance: uint256
    # Code of the account deployed by CREATE.
    deployedCode: Bytes[1024]
    # Value passed along with the account access
    value_: uint256
    # Input data provided to the CREATE or CALL
    data: Bytes[1024]
    # If this access reverted in either the current or parent context.
    reverted: bool
    # An ordered list of storage accesses made during an account access operation.
    storageAccesses: DynArray[StorageAccess, 1024]
    # Call depth traversed during the recording of state differences
    depth: uint64

# The storage accessed during an `AccountAccess`.
struct StorageAccess:
    # The account whose storage was accessed.
    account: address
    # The slot that was accessed.
    slot: bytes32
    # If the access was a write.
    isWrite: bool
    # The previous value of the slot.
    previousValue: bytes32
    # The new value of the slot.
    newValue: bytes32
    # If the access was reverted.
    reverted: bool

# Gas used. Returned by `lastCallGas`.
struct Gas:
    # The gas limit of the call.
    gasLimit: uint64
    # The total gas used.
    gasTotalUsed: uint64
    # DEPRECATED: The amount of gas used for memory expansion. Ref: <https://github.com/foundry-rs/foundry/pull/7934#pullrequestreview-2069236939>
    gasMemoryUsed: uint64
    # The amount of gas refunded.
    gasRefunded: int64
    # The amount of gas remaining.
    gasRemaining: uint64

interface Vm:
    # Gets all accessed reads and write slot from a `vm.record` session, for a given address.
    def accesses(target: address) -> (DynArray[bytes32, 1024], DynArray[bytes32, 1024]): nonpayable

    # Returns the identifier of the currently active fork. Reverts if no fork is currently active.
    def activeFork() -> uint256: view

    # Gets the address for a given private key.
    def addr(privateKey: uint256) -> address: nonpayable

    # In forking mode, explicitly grant the given address cheatcode access.
    def allowCheatcodes(account: address): nonpayable

    # Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
    # Formats values with decimals in failure message.
    def assertApproxEqAbsDecimal(left: uint256, right: uint256, maxDelta: uint256, decimals: uint256): nonpayable

    # Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
    def assertApproxEqAbs(left: uint256, right: uint256, maxDelta: uint256): nonpayable

    # Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
    # `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
    # Formats values with decimals in failure message.
    def assertApproxEqRelDecimal(left: uint256, right: uint256, maxPercentDelta: uint256, decimals: uint256): nonpayable

    # Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
    # `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
    def assertApproxEqRel(left: uint256, right: uint256, maxPercentDelta: uint256): nonpayable

    # Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
    def assertEqDecimal(left: uint256, right: uint256, decimals: uint256): nonpayable

    # Asserts that two `bool` values are equal.
    def assertEq(left: bool, right: bool): nonpayable

    # Asserts that the given condition is false.
    def assertFalse(condition: bool): nonpayable

    # Compares two `uint256` values. Expects first value to be greater than or equal to second.
    # Formats values with decimals in failure message.
    def assertGeDecimal(left: uint256, right: uint256, decimals: uint256): nonpayable

    # Compares two `uint256` values. Expects first value to be greater than or equal to second.
    def assertGe(left: uint256, right: uint256): nonpayable

    # Compares two `uint256` values. Expects first value to be greater than second.
    # Formats values with decimals in failure message.
    def assertGtDecimal(left: uint256, right: uint256, decimals: uint256): nonpayable

    # Compares two `uint256` values. Expects first value to be greater than second.
    def assertGt(left: uint256, right: uint256): nonpayable

    # Compares two `uint256` values. Expects first value to be less than or equal to second.
    # Formats values with decimals in failure message.
    def assertLeDecimal(left: uint256, right: uint256, decimals: uint256): nonpayable

    # Compares two `uint256` values. Expects first value to be less than or equal to second.
    def assertLe(left: uint256, right: uint256): nonpayable

    # Compares two `uint256` values. Expects first value to be less than second.
    # Formats values with decimals in failure message.
    def assertLtDecimal(left: uint256, right: uint256, decimals: uint256): nonpayable

    # Compares two `uint256` values. Expects first value to be less than second.
    def assertLt(left: uint256, right: uint256): nonpayable

    # Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
    def assertNotEqDecimal(left: uint256, right: uint256, decimals: uint256): nonpayable

    # Asserts that two `bool` values are not equal.
    def assertNotEq(left: bool, right: bool): nonpayable

    # Asserts that the given condition is true.
    def assertTrue(condition: bool): nonpayable

    # If the condition is false, discard this run's fuzz inputs and generate new ones.
    def assume(condition: bool): nonpayable

    # Sets `block.blobbasefee`
    def blobBaseFee(newBlobBaseFee: uint256): nonpayable

    # Sets the blobhashes in the transaction.
    # Not available on EVM versions before Cancun.
    # If used on unsupported EVM versions it will revert.
    def blobhashes(hashes: DynArray[bytes32, 1024]): nonpayable

    # Writes a breakpoint to jump to in the debugger.
    def breakpoint(char: String[1024]): nonpayable

    # Has the next call (at this call depth only) create transactions that can later be signed and sent onchain.
    # Broadcasting address is determined by checking the following in order:
    # 1. If `--sender` argument was provided, that address is used.
    # 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.
    # 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
    def broadcast(): nonpayable

    # Sets `block.chainid`.
    def chainId(newChainId: uint256): nonpayable

    # Clears all mocked calls.
    def clearMockedCalls(): nonpayable

    # Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.
    # `path` is relative to the project root.
    def closeFile(path: String[1024]): nonpayable

    # Sets `block.coinbase`.
    def coinbase(newCoinbase: address): nonpayable

    # Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.
    def computeCreate2Address(salt: bytes32, initCodeHash: bytes32, deployer: address) -> address: nonpayable

    # Compute the address a contract will be deployed at for a given deployer address and nonce.
    def computeCreateAddress(deployer: address, nonce: uint256) -> address: nonpayable

    # Copies the contents of one file to another. This function will **overwrite** the contents of `to`.
    # On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.
    # Both `from` and `to` are relative to the project root.
    def copyFile(from_: String[1024], to: String[1024]) -> uint64: nonpayable

    # Creates a new, empty directory at the provided path.
    # This cheatcode will revert in the following situations, but is not limited to just these cases:
    # - User lacks permissions to modify `path`.
    # - A parent of the given path doesn't exist and `recursive` is false.
    # - `path` already exists and `recursive` is false.
    # `path` is relative to the project root.
    def createDir(path: String[1024], recursive: bool): nonpayable

    # Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.
    def createFork(urlOrAlias: String[1024]) -> uint256: nonpayable

    # Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.
    def createSelectFork(urlOrAlias: String[1024]) -> uint256: nonpayable

    # Derives a private key from the name, labels the account with that name, and returns the wallet.
    def createWallet(walletLabel: String[1024]) -> Wallet: nonpayable

    # Sets an address' balance.
    def deal(account: address, newBalance: uint256): nonpayable

    # Removes the snapshot with the given ID created by `snapshot`.
    # Takes the snapshot ID to delete.
    # Returns `true` if the snapshot was successfully deleted.
    # Returns `false` if the snapshot does not exist.
    def deleteSnapshot(snapshotId: uint256) -> bool: nonpayable

    # Removes _all_ snapshots previously created by `snapshot`.
    def deleteSnapshots(): nonpayable

    # Derive a private key from a provided mnenomic string (or mnenomic file path)
    # at the derivation path `m/44'/60'/0'/0/{index}`.
    def deriveKey(mnemonic: String[1024], index: uint32) -> uint256: nonpayable

    # Sets `block.difficulty`.
    # Not available on EVM versions from Paris onwards. Use `prevrandao` instead.
    # Reverts if used on unsupported EVM versions.
    def difficulty(newDifficulty: uint256): nonpayable

    # Dump a genesis JSON file's `allocs` to disk.
    def dumpState(pathToStateJson: String[1024]): nonpayable

    # Returns ENS namehash for provided string.
    def ensNamehash(name: String[1024]) -> bytes32: nonpayable

    # Gets the environment variable `name` and parses it as `address`.
    # Reverts if the variable was not found or could not be parsed.
    def envAddress(name: String[1024]) -> address: view

    # Gets the environment variable `name` and parses it as `bool`.
    # Reverts if the variable was not found or could not be parsed.
    def envBool(name: String[1024]) -> bool: view

    # Gets the environment variable `name` and parses it as `bytes32`.
    # Reverts if the variable was not found or could not be parsed.
    def envBytes32(name: String[1024]) -> bytes32: view

    # Gets the environment variable `name` and parses it as `bytes`.
    # Reverts if the variable was not found or could not be parsed.
    def envBytes(name: String[1024]) -> Bytes[1024]: view

    # Gets the environment variable `name` and returns true if it exists, else returns false.
    def envExists(name: String[1024]) -> bool: view

    # Gets the environment variable `name` and parses it as `int256`.
    # Reverts if the variable was not found or could not be parsed.
    def envInt(name: String[1024]) -> int256: view

    # Gets the environment variable `name` and parses it as `bool`.
    # Reverts if the variable could not be parsed.
    # Returns `defaultValue` if the variable was not found.
    def envOr(name: String[1024], defaultValue: bool) -> bool: view

    # Gets the environment variable `name` and parses it as `string`.
    # Reverts if the variable was not found or could not be parsed.
    def envString(name: String[1024]) -> String[1024]: view

    # Gets the environment variable `name` and parses it as `uint256`.
    # Reverts if the variable was not found or could not be parsed.
    def envUint(name: String[1024]) -> uint256: view

    # Sets an address' code.
    def etch(target: address, newRuntimeBytecode: Bytes[1024]): nonpayable

    # Gets all the logs according to specified filter.
    def eth_getLogs(fromBlock: uint256, toBlock: uint256, target: address, topics: DynArray[bytes32, 1024]) -> DynArray[EthGetLogs, 1024]: nonpayable

    # Returns true if the given path points to an existing entity, else returns false.
    def exists(path: String[1024]) -> bool: nonpayable

    # Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
    def expectCallMinGas(callee: address, msgValue: uint256, minGas: uint64, data: Bytes[1024]): nonpayable

    # Expects a call to an address with the specified calldata.
    # Calldata can either be a strict or a partial match.
    def expectCall(callee: address, data: Bytes[1024]): nonpayable

    # Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).
    # Call this function, then emit an event, then call a function. Internally after the call, we check if
    # logs were emitted in the expected order with the expected topics and data (as specified by the booleans).
    def expectEmit(checkTopic1: bool, checkTopic2: bool, checkTopic3: bool, checkData: bool): nonpayable

    # Expects an error on next call with any revert data.
    def expectRevert(): nonpayable

    # Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the current subcontext. If any other
    # memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.
    def expectSafeMemory(min: uint64, max: uint64): nonpayable

    # Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the next created subcontext.
    # If any other memory is written to, the test will fail. Can be called multiple times to add more ranges
    # to the set.
    def expectSafeMemoryCall(min: uint64, max: uint64): nonpayable

    # Sets `block.basefee`.
    def fee(newBasefee: uint256): nonpayable

    # Performs a foreign function call via the terminal.
    def ffi(commandInput: DynArray[String[1024], 1024]) -> Bytes[1024]: nonpayable

    # Given a path, query the file system to get information about a file, directory, etc.
    def fsMetadata(path: String[1024]) -> FsMetadata: view

    # Gets the current `block.blobbasefee`.
    # You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction,
    # and as a result will get optimized out by the compiler.
    # See https://github.com/foundry-rs/foundry/issues/6180
    def getBlobBaseFee() -> uint256: view

    # Gets the blockhashes from the current transaction.
    # Not available on EVM versions before Cancun.
    # If used on unsupported EVM versions it will revert.
    def getBlobhashes() -> DynArray[bytes32, 1024]: view

    # Gets the current `block.number`.
    # You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction,
    # and as a result will get optimized out by the compiler.
    # See https://github.com/foundry-rs/foundry/issues/6180
    def getBlockNumber() -> uint256: view

    # Gets the current `block.timestamp`.
    # You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction,
    # and as a result will get optimized out by the compiler.
    # See https://github.com/foundry-rs/foundry/issues/6180
    def getBlockTimestamp() -> uint256: view

    # Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the
    # artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
    def getCode(artifactPath: String[1024]) -> Bytes[1024]: view

    # Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the
    # artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
    def getDeployedCode(artifactPath: String[1024]) -> Bytes[1024]: view

    # Gets the label for the specified address.
    def getLabel(account: address) -> String[1024]: view

    # Gets the map key and parent of a mapping at a given slot, for a given address.
    def getMappingKeyAndParentOf(target: address, elementSlot: bytes32) -> (bool, bytes32, bytes32): nonpayable

    # Gets the number of elements in the mapping at the given slot, for a given address.
    def getMappingLength(target: address, mappingSlot: bytes32) -> uint256: nonpayable

    # Gets the elements at index idx of the mapping at the given slot, for a given address. The
    # index must be less than the length of the mapping (i.e. the number of keys in the mapping).
    def getMappingSlotAt(target: address, mappingSlot: bytes32, idx: uint256) -> bytes32: nonpayable

    # Gets the nonce of an account.
    def getNonce(account: address) -> uint64: view

    # Gets all the recorded logs.
    def getRecordedLogs() -> DynArray[Log, 1024]: nonpayable

    # Returns the index of the first occurrence of a `key` in an `input` string.
    # Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found.
    # Returns 0 in case of an empty `key`.
    def indexOf(input: String[1024], key: String[1024]) -> uint256: nonpayable

    # Returns true if `forge` command was executed in given context.
    def isContext(context: ForgeContext) -> bool: view

    # Returns true if the path exists on disk and is pointing at a directory, else returns false.
    def isDir(path: String[1024]) -> bool: nonpayable

    # Returns true if the path exists on disk and is pointing at a regular file, else returns false.
    def isFile(path: String[1024]) -> bool: nonpayable

    # Returns true if the account is marked as persistent.
    def isPersistent(account: address) -> bool: view

    # Checks if `key` exists in a JSON object
    # `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.
    def keyExists(json: String[1024], key: String[1024]) -> bool: view

    # Checks if `key` exists in a JSON object.
    def keyExistsJson(json: String[1024], key: String[1024]) -> bool: view

    # Checks if `key` exists in a TOML table.
    def keyExistsToml(toml: String[1024], key: String[1024]) -> bool: view

    # Labels an address in call traces.
    def label(account: address, newLabel: String[1024]): nonpayable

    # Gets the gas used in the last call.
    def lastCallGas() -> Gas: view

    # Loads a storage slot from an address.
    def load(target: address, slot: bytes32) -> bytes32: view

    # Load a genesis JSON file's `allocs` into the in-memory revm state.
    def loadAllocs(pathToAllocsJson: String[1024]): nonpayable

    # Marks that the account(s) should use persistent storage across fork swaps in a multifork setup
    # Meaning, changes made to the state of this account will be kept when switching forks.
    def makePersistent(account: address): nonpayable

    # Reverts a call to an address with specified revert data.
    def mockCallRevert(callee: address, data: Bytes[1024], revertData: Bytes[1024]): nonpayable

    # Mocks a call to an address, returning specified data.
    # Calldata can either be strict or a partial match, e.g. if you only
    # pass a Solidity selector to the expected calldata, then the entire Solidity
    # function will be mocked.
    def mockCall(callee: address, data: Bytes[1024], returnData: Bytes[1024]): nonpayable

    # Parses the given `string` into an `address`.
    def parseAddress(stringifiedValue: String[1024]) -> address: nonpayable

    # Parses the given `string` into a `bool`.
    def parseBool(stringifiedValue: String[1024]) -> bool: nonpayable

    # Parses the given `string` into `bytes`.
    def parseBytes(stringifiedValue: String[1024]) -> Bytes[1024]: nonpayable

    # Parses the given `string` into a `bytes32`.
    def parseBytes32(stringifiedValue: String[1024]) -> bytes32: nonpayable

    # Parses the given `string` into a `int256`.
    def parseInt(stringifiedValue: String[1024]) -> int256: nonpayable

    # Parses a string of JSON data at `key` and coerces it to `address`.
    def parseJsonAddress(json: String[1024], key: String[1024]) -> address: nonpayable

    # Parses a string of JSON data at `key` and coerces it to `address[]`.
    def parseJsonAddressArray(json: String[1024], key: String[1024]) -> DynArray[address, 1024]: nonpayable

    # Parses a string of JSON data at `key` and coerces it to `bool`.
    def parseJsonBool(json: String[1024], key: String[1024]) -> bool: nonpayable

    # Parses a string of JSON data at `key` and coerces it to `bool[]`.
    def parseJsonBoolArray(json: String[1024], key: String[1024]) -> DynArray[bool, 1024]: nonpayable

    # Parses a string of JSON data at `key` and coerces it to `bytes`.
    def parseJsonBytes(json: String[1024], key: String[1024]) -> Bytes[1024]: nonpayable

    # Parses a string of JSON data at `key` and coerces it to `bytes32`.
    def parseJsonBytes32(json: String[1024], key: String[1024]) -> bytes32: nonpayable

    # Parses a string of JSON data at `key` and coerces it to `bytes32[]`.
    def parseJsonBytes32Array(json: String[1024], key: String[1024]) -> DynArray[bytes32, 1024]: nonpayable

    # Parses a string of JSON data at `key` and coerces it to `bytes[]`.
    def parseJsonBytesArray(json: String[1024], key: String[1024]) -> DynArray[Bytes[1024], 1024]: nonpayable

    # Parses a string of JSON data at `key` and coerces it to `int256`.
    def parseJsonInt(json: String[1024], key: String[1024]) -> int256: nonpayable

    # Parses a string of JSON data at `key` and coerces it to `int256[]`.
    def parseJsonIntArray(json: String[1024], key: String[1024]) -> DynArray[int256, 1024]: nonpayable

    # Returns an array of all the keys in a JSON object.
    def parseJsonKeys(json: String[1024], key: String[1024]) -> DynArray[String[1024], 1024]: nonpayable

    # Parses a string of JSON data at `key` and coerces it to `string`.
    def parseJsonString(json: String[1024], key: String[1024]) -> String[1024]: nonpayable

    # Parses a string of JSON data at `key` and coerces it to `string[]`.
    def parseJsonStringArray(json: String[1024], key: String[1024]) -> DynArray[String[1024], 1024]: nonpayable

    # Parses a string of JSON data at `key` and coerces it to `uint256`.
    def parseJsonUint(json: String[1024], key: String[1024]) -> uint256: nonpayable

    # Parses a string of JSON data at `key` and coerces it to `uint256[]`.
    def parseJsonUintArray(json: String[1024], key: String[1024]) -> DynArray[uint256, 1024]: nonpayable

    # ABI-encodes a JSON object.
    def parseJson(json: String[1024]) -> Bytes[1024]: nonpayable

    # Parses a string of TOML data at `key` and coerces it to `address`.
    def parseTomlAddress(toml: String[1024], key: String[1024]) -> address: nonpayable

    # Parses a string of TOML data at `key` and coerces it to `address[]`.
    def parseTomlAddressArray(toml: String[1024], key: String[1024]) -> DynArray[address, 1024]: nonpayable

    # Parses a string of TOML data at `key` and coerces it to `bool`.
    def parseTomlBool(toml: String[1024], key: String[1024]) -> bool: nonpayable

    # Parses a string of TOML data at `key` and coerces it to `bool[]`.
    def parseTomlBoolArray(toml: String[1024], key: String[1024]) -> DynArray[bool, 1024]: nonpayable

    # Parses a string of TOML data at `key` and coerces it to `bytes`.
    def parseTomlBytes(toml: String[1024], key: String[1024]) -> Bytes[1024]: nonpayable

    # Parses a string of TOML data at `key` and coerces it to `bytes32`.
    def parseTomlBytes32(toml: String[1024], key: String[1024]) -> bytes32: nonpayable

    # Parses a string of TOML data at `key` and coerces it to `bytes32[]`.
    def parseTomlBytes32Array(toml: String[1024], key: String[1024]) -> DynArray[bytes32, 1024]: nonpayable

    # Parses a string of TOML data at `key` and coerces it to `bytes[]`.
    def parseTomlBytesArray(toml: String[1024], key: String[1024]) -> DynArray[Bytes[1024], 1024]: nonpayable

    # Parses a string of TOML data at `key` and coerces it to `int256`.
    def parseTomlInt(toml: String[1024], key: String[1024]) -> int256: nonpayable

    # Parses a string of TOML data at `key` and coerces it to `int256[]`.
    def parseTomlIntArray(toml: String[1024], key: String[1024]) -> DynArray[int256, 1024]: nonpayable

    # Returns an array of all the keys in a TOML table.
    def parseTomlKeys(toml: String[1024], key: String[1024]) -> DynArray[String[1024], 1024]: nonpayable

    # Parses a string of TOML data at `key` and coerces it to `string`.
    def parseTomlString(toml: String[1024], key: String[1024]) -> String[1024]: nonpayable

    # Parses a string of TOML data at `key` and coerces it to `string[]`.
    def parseTomlStringArray(toml: String[1024], key: String[1024]) -> DynArray[String[1024], 1024]: nonpayable

    # Parses a string of TOML data at `key` and coerces it to `uint256`.
    def parseTomlUint(toml: String[1024], key: String[1024]) -> uint256: nonpayable

    # Parses a string of TOML data at `key` and coerces it to `uint256[]`.
    def parseTomlUintArray(toml: String[1024], key: String[1024]) -> DynArray[uint256, 1024]: nonpayable

    # ABI-encodes a TOML table.
    def parseToml(toml: String[1024]) -> Bytes[1024]: nonpayable

    # Parses the given `string` into a `uint256`.
    def parseUint(stringifiedValue: String[1024]) -> uint256: nonpayable

    # Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
    def pauseGasMetering(): nonpayable

    # Sets the *next* call's `msg.sender` to be the input address.
    def prank(msgSender: address): nonpayable

    # Sets `block.prevrandao`.
    # Not available on EVM versions before Paris. Use `difficulty` instead.
    # If used on unsupported EVM versions it will revert.
    def prevrandao(newPrevrandao: bytes32): nonpayable

    # Get the path of the current project root.
    def projectRoot() -> String[1024]: view

    # Prompts the user for a string value in the terminal.
    def prompt(promptText: String[1024]) -> String[1024]: nonpayable

    # Prompts the user for an address in the terminal.
    def promptAddress(promptText: String[1024]) -> address: nonpayable

    # Prompts the user for a hidden string value in the terminal.
    def promptSecret(promptText: String[1024]) -> String[1024]: nonpayable

    # Prompts the user for hidden uint256 in the terminal (usually pk).
    def promptSecretUint(promptText: String[1024]) -> uint256: nonpayable

    # Prompts the user for uint256 in the terminal.
    def promptUint(promptText: String[1024]) -> uint256: nonpayable

    # Returns a random `address`.
    def randomAddress() -> address: nonpayable

    # Returns a random uint256 value.
    def randomUint() -> uint256: nonpayable

    # Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.
    def readCallers() -> (CallerMode, address, address): nonpayable

    # Reads the directory at the given path recursively, up to `maxDepth`.
    # `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned.
    # Follows symbolic links if `followLinks` is true.
    def readDir(path: String[1024]) -> DynArray[DirEntry, 1024]: view

    # Reads the entire content of file to string. `path` is relative to the project root.
    def readFile(path: String[1024]) -> String[1024]: view

    # Reads the entire content of file as binary. `path` is relative to the project root.
    def readFileBinary(path: String[1024]) -> Bytes[1024]: view

    # Reads next line of file to string.
    def readLine(path: String[1024]) -> String[1024]: view

    # Reads a symbolic link, returning the path that the link points to.
    # This cheatcode will revert in the following situations, but is not limited to just these cases:
    # - `path` is not a symbolic link.
    # - `path` does not exist.
    def readLink(linkPath: String[1024]) -> String[1024]: view

    # Records all storage reads and writes.
    def record(): nonpayable

    # Record all the transaction logs.
    def recordLogs(): nonpayable

    # Adds a private key to the local forge wallet and returns the address.
    def rememberKey(privateKey: uint256) -> address: nonpayable

    # Removes a directory at the provided path.
    # This cheatcode will revert in the following situations, but is not limited to just these cases:
    # - `path` doesn't exist.
    # - `path` isn't a directory.
    # - User lacks permissions to modify `path`.
    # - The directory is not empty and `recursive` is false.
    # `path` is relative to the project root.
    def removeDir(path: String[1024], recursive: bool): nonpayable

    # Removes a file from the filesystem.
    # This cheatcode will revert in the following situations, but is not limited to just these cases:
    # - `path` points to a directory.
    # - The file doesn't exist.
    # - The user lacks permissions to remove the file.
    # `path` is relative to the project root.
    def removeFile(path: String[1024]): nonpayable

    # Replaces occurrences of `from` in the given `string` with `to`.
    def replace(input: String[1024], from_: String[1024], to: String[1024]) -> String[1024]: nonpayable

    # Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.
    def resetNonce(account: address): nonpayable

    # Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
    def resumeGasMetering(): nonpayable

    # Revert the state of the EVM to a previous snapshot
    # Takes the snapshot ID to revert to.
    # Returns `true` if the snapshot was successfully reverted.
    # Returns `false` if the snapshot does not exist.
    # **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteSnapshot`.
    def revertTo(snapshotId: uint256) -> bool: nonpayable

    # Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots
    # Takes the snapshot ID to revert to.
    # Returns `true` if the snapshot was successfully reverted and deleted.
    # Returns `false` if the snapshot does not exist.
    def revertToAndDelete(snapshotId: uint256) -> bool: nonpayable

    # Revokes persistent status from the address, previously added via `makePersistent`.
    def revokePersistent(account: address): nonpayable

    # Sets `block.height`.
    def roll(newHeight: uint256): nonpayable

    # Updates the currently active fork to given block number
    # This is similar to `roll` but for the currently active fork.
    def rollFork(blockNumber: uint256): nonpayable

    # Performs an Ethereum JSON-RPC request to the current fork URL.
    def rpc(method: String[1024], params: String[1024]) -> Bytes[1024]: nonpayable

    # Returns the RPC url for the given alias.
    def rpcUrl(rpcAlias: String[1024]) -> String[1024]: view

    # Returns all rpc urls and their aliases as structs.
    def rpcUrlStructs() -> DynArray[Rpc, 1024]: view

    # Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.
    def selectFork(forkId: uint256): nonpayable

    # See `serializeJson`.
    def serializeAddress(objectKey: String[1024], valueKey: String[1024], value_: address) -> String[1024]: nonpayable

    # See `serializeJson`.
    def serializeBool(objectKey: String[1024], valueKey: String[1024], value_: bool) -> String[1024]: nonpayable

    # See `serializeJson`.
    def serializeBytes32(objectKey: String[1024], valueKey: String[1024], value_: bytes32) -> String[1024]: nonpayable

    # See `serializeJson`.
    def serializeBytes(objectKey: String[1024], valueKey: String[1024], value_: Bytes[1024]) -> String[1024]: nonpayable

    # See `serializeJson`.
    def serializeInt(objectKey: String[1024], valueKey: String[1024], value_: int256) -> String[1024]: nonpayable

    # Serializes a key and value to a JSON object stored in-memory that can be later written to a file.
    # Returns the stringified version of the specific JSON file up to that moment.
    def serializeJson(objectKey: String[1024], value_: String[1024]) -> String[1024]: nonpayable

    # See `serializeJson`.
    def serializeString(objectKey: String[1024], valueKey: String[1024], value_: String[1024]) -> String[1024]: nonpayable

    # See `serializeJson`.
    def serializeUintToHex(objectKey: String[1024], valueKey: String[1024], value_: uint256) -> String[1024]: nonpayable

    # See `serializeJson`.
    def serializeUint(objectKey: String[1024], valueKey: String[1024], value_: uint256) -> String[1024]: nonpayable

    # Sets environment variables.
    def setEnv(name: String[1024], value_: String[1024]): nonpayable

    # Sets the nonce of an account. Must be higher than the current nonce of the account.
    def setNonce(account: address, newNonce: uint64): nonpayable

    # Sets the nonce of an account to an arbitrary value.
    def setNonceUnsafe(account: address, newNonce: uint64): nonpayable

    # Signs `digest` with `privateKey` using the secp256r1 curve.
    def signP256(privateKey: uint256, digest: bytes32) -> (bytes32, bytes32): nonpayable

    # Signs `digest` with `privateKey` using the secp256k1 curve.
    def sign(privateKey: uint256, digest: bytes32) -> (uint8, bytes32, bytes32): nonpayable

    # Marks a test as skipped. Must be called at the top of the test.
    def skip(skipTest: bool): nonpayable

    # Suspends execution of the main thread for `duration` milliseconds.
    def sleep(duration: uint256): nonpayable

    # Snapshot the current state of the evm.
    # Returns the ID of the snapshot that was created.
    # To revert a snapshot use `revertTo`.
    def snapshot() -> uint256: nonpayable

    # Splits the given `string` into an array of strings divided by the `delimiter`.
    def split(input: String[1024], delimiter: String[1024]) -> DynArray[String[1024], 1024]: nonpayable

    # Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain.
    # Broadcasting address is determined by checking the following in order:
    # 1. If `--sender` argument was provided, that address is used.
    # 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.
    # 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
    def startBroadcast(): nonpayable

    # Starts recording all map SSTOREs for later retrieval.
    def startMappingRecording(): nonpayable

    # Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.
    def startPrank(msgSender: address): nonpayable

    # Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order,
    # along with the context of the calls
    def startStateDiffRecording(): nonpayable

    # Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.
    def stopAndReturnStateDiff() -> DynArray[AccountAccess, 1024]: nonpayable

    # Stops collecting onchain transactions.
    def stopBroadcast(): nonpayable

    # Stops all safe memory expectation in the current subcontext.
    def stopExpectSafeMemory(): nonpayable

    # Stops recording all map SSTOREs for later retrieval and clears the recorded data.
    def stopMappingRecording(): nonpayable

    # Resets subsequent calls' `msg.sender` to be `address(this)`.
    def stopPrank(): nonpayable

    # Stores a value to an address' storage slot.
    def store(target: address, slot: bytes32, value_: bytes32): nonpayable

    # Encodes a `bytes` value to a base64url string.
    def toBase64URL(data: Bytes[1024]) -> String[1024]: nonpayable

    # Encodes a `bytes` value to a base64 string.
    def toBase64(data: Bytes[1024]) -> String[1024]: nonpayable

    # Converts the given `string` value to Lowercase.
    def toLowercase(input: String[1024]) -> String[1024]: nonpayable

    # Converts the given value to a `string`.
    def toString(value_: address) -> String[1024]: nonpayable

    # Converts the given `string` value to Uppercase.
    def toUppercase(input: String[1024]) -> String[1024]: nonpayable

    # Fetches the given transaction from the active fork and executes it on the current state.
    def transact(txHash: bytes32): nonpayable

    # Trims leading and trailing whitespace from the given `string` value.
    def trim(input: String[1024]) -> String[1024]: nonpayable

    # Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.
    def tryFfi(commandInput: DynArray[String[1024], 1024]) -> FfiResult: nonpayable

    # Sets `tx.gasprice`.
    def txGasPrice(newGasPrice: uint256): nonpayable

    # Returns the time since unix epoch in milliseconds.
    def unixTime() -> uint256: nonpayable

    # Sets `block.timestamp`.
    def warp(newTimestamp: uint256): nonpayable

    # Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.
    # `path` is relative to the project root.
    def writeFile(path: String[1024], data: String[1024]): nonpayable

    # Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.
    # `path` is relative to the project root.
    def writeFileBinary(path: String[1024], data: Bytes[1024]): nonpayable

    # Write a serialized JSON object to a file. If the file exists, it will be overwritten.
    def writeJson(json: String[1024], path: String[1024]): nonpayable

    # Writes line to file, creating a file if it does not exist.
    # `path` is relative to the project root.
    def writeLine(path: String[1024], data: String[1024]): nonpayable

    # Takes serialized JSON, converts to TOML and write a serialized TOML to a file.
    def writeToml(json: String[1024], path: String[1024]): nonpayable

vm: constant(Vm) = Vm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)
